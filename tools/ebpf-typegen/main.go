// Copyright Antimetal, Inc. All rights reserved.
//
// Use of this source code is governed by a source available license that can be found in the
// LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type Config struct {
	InputFile  string
	OutputFile string
	Package    string
	Verbose    bool
}

// ErrorType represents different categories of errors
type ErrorType string

const (
	ErrTypeConfig     ErrorType = "configuration"
	ErrTypeIO         ErrorType = "io"
	ErrTypeParsing    ErrorType = "parsing"
	ErrTypeGeneration ErrorType = "generation"
	ErrTypeValidation ErrorType = "validation"
)

// TypegenError represents a categorized error with context
type TypegenError struct {
	Type    ErrorType
	Message string
	File    string
	Line    int
	Cause   error
}

func (e *TypegenError) Error() string {
	if e.File != "" {
		if e.Line > 0 {
			return fmt.Sprintf("%s error in %s:%d: %s", e.Type, e.File, e.Line, e.Message)
		}
		return fmt.Sprintf("%s error in %s: %s", e.Type, e.File, e.Message)
	}
	return fmt.Sprintf("%s error: %s", e.Type, e.Message)
}

func (e *TypegenError) Unwrap() error {
	return e.Cause
}

// Logger provides structured logging with levels
type Logger struct {
	verbose bool
}

func (l *Logger) Info(msg string, args ...interface{}) {
	log.Printf("INFO: "+msg, args...)
}

func (l *Logger) Warn(msg string, args ...interface{}) {
	log.Printf("WARN: "+msg, args...)
}

func (l *Logger) Error(msg string, args ...interface{}) {
	log.Printf("ERROR: "+msg, args...)
}

func (l *Logger) Debug(msg string, args ...interface{}) {
	if l.verbose {
		log.Printf("DEBUG: "+msg, args...)
	}
}

var logger *Logger

type StructField struct {
	Name     string
	CType    string
	GoType   string
	Size     int
	IsArray  bool
	ArrayLen int
	Comment  string
}

type Struct struct {
	Name   string
	Fields []StructField
}

type Constant struct {
	Name  string
	Value string
}

type FileData struct {
	Package      string
	InputFile    string
	Structs      []Struct
	Constants    []Constant
	SourceHeader string
}

const goTemplate = `// Code generated by ebpf-typegen. DO NOT EDIT.
// Source: {{ .InputFile }}

// Copyright Antimetal, Inc. All rights reserved.
//
// Use of this source code is governed by a source available license that can be found in the
// LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

package {{ .Package }}

// NOTE: These structs match the binary layout of GPL-licensed BPF code.
// The Go code itself is NOT derived from GPL code - it merely provides
// compatible data structures for kernel communication.

{{- if .Constants }}

// Constants matching BPF definitions
const (
{{- range .Constants }}
	{{ .Name }} = {{ .Value }}
{{- end }}
)
{{- end }}

{{- range .Structs }}

// {{ .Name }} matches the C struct layout from the GPL BPF code.
// This Go struct is NOT derived from GPL code - it merely matches the binary layout
// for data exchange purposes. The data structure layout itself is not copyrightable.
type {{ .Name }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .GoType }}{{ if .Comment }} // {{ .Comment }}{{ end }}
{{- end }}
}
{{- end }}
`

var (
	cToGoTypes = map[string]string{
		"__s32":    "int32",
		"__u32":    "uint32",
		"__s64":    "int64",
		"__u64":    "uint64",
		"__s16":    "int16",
		"__u16":    "uint16",
		"__s8":     "int8",
		"__u8":     "uint8",
		"char":     "byte",
		"int":      "int32",
		"unsigned": "uint32",
	}

	// Known constants for array sizes
	knownConstants = map[string]int{
		"TASK_COMM_LEN":     16,
		"ARGSIZE":           128,
		"TOTAL_MAX_ARGS":    60,
		"FULL_MAX_ARGS_ARR": 60 * 128,
	}

	titleCase = cases.Title(language.English)

	// Pre-compiled regex patterns for performance
	defineRe = regexp.MustCompile(`#define\s+([A-Z_]+)\s+(\d+)`)
	structRe = regexp.MustCompile(`(?s)struct\s+(\w+)\s*\{([^}]+)\}`)
	arrayRe  = regexp.MustCompile(`^(\S+)\s+(\w+)\[(\w+)\]$`)
	fieldRe  = regexp.MustCompile(`^(\S+)\s+(\w+)$`)
)

func main() {
	var cfg Config
	flag.StringVar(&cfg.InputFile, "input", "", "Input C header file")
	flag.StringVar(&cfg.OutputFile, "output", "", "Output Go file")
	flag.StringVar(&cfg.Package, "package", "collectors", "Go package name")
	flag.BoolVar(&cfg.Verbose, "verbose", false, "Enable verbose logging")
	flag.Parse()

	logger = &Logger{verbose: cfg.Verbose}

	if err := validateConfig(cfg); err != nil {
		logger.Error("Configuration validation failed: %v", err)
		os.Exit(1)
	}

	if err := generate(cfg); err != nil {
		var typgenErr *TypegenError
		if errors.As(err, &typgenErr) {
			logger.Error("%s", typgenErr.Error())
			if typgenErr.Cause != nil {
				logger.Debug("Underlying error: %v", typgenErr.Cause)
			}
		} else {
			logger.Error("Generation failed: %v", err)
		}
		os.Exit(1)
	}

	logger.Info("Generated %s from %s", cfg.OutputFile, cfg.InputFile)
}

func validateConfig(cfg Config) error {
	if cfg.InputFile == "" || cfg.OutputFile == "" {
		return &TypegenError{
			Type:    ErrTypeConfig,
			Message: "Both -input and -output flags are required",
		}
	}

	// Validate input file exists and has correct extension
	if _, err := os.Stat(cfg.InputFile); err != nil {
		return &TypegenError{
			Type:    ErrTypeConfig,
			Message: fmt.Sprintf("Input file does not exist: %s", cfg.InputFile),
			File:    cfg.InputFile,
			Cause:   err,
		}
	}

	if !strings.HasSuffix(cfg.InputFile, ".h") {
		return &TypegenError{
			Type:    ErrTypeConfig,
			Message: fmt.Sprintf("Input file must have .h extension: %s", cfg.InputFile),
			File:    cfg.InputFile,
		}
	}

	// Validate output directory exists and is writable
	outputDir := filepath.Dir(cfg.OutputFile)
	if outputDir != "." {
		if _, err := os.Stat(outputDir); err != nil {
			return &TypegenError{
				Type:    ErrTypeConfig,
				Message: fmt.Sprintf("Output directory does not exist: %s", outputDir),
				File:    cfg.OutputFile,
				Cause:   err,
			}
		}
	}

	// Validate Go package name format
	if !isValidGoPackageName(cfg.Package) {
		return &TypegenError{
			Type:    ErrTypeConfig,
			Message: fmt.Sprintf("Invalid Go package name: %s", cfg.Package),
		}
	}

	return nil
}

func isValidGoPackageName(name string) bool {
	if name == "" {
		return false
	}
	for i, r := range name {
		if i == 0 {
			if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || r == '_') {
				return false
			}
		} else {
			if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_') {
				return false
			}
		}
	}
	return true
}

func validateParsedData(data FileData) error {
	if len(data.Structs) == 0 && len(data.Constants) == 0 {
		return &TypegenError{
			Type:    ErrTypeValidation,
			Message: "No structs or constants found in input file",
		}
	}

	// Check for empty structs
	for _, s := range data.Structs {
		if len(s.Fields) == 0 {
			logger.Warn("Struct %s has no fields", s.Name)
		}
	}

	// Validate field types
	for _, s := range data.Structs {
		for _, field := range s.Fields {
			if field.GoType == "" {
				return &TypegenError{
					Type:    ErrTypeValidation,
					Message: fmt.Sprintf("Field %s in struct %s has empty Go type", field.Name, s.Name),
				}
			}
		}
	}

	return nil
}

func generate(cfg Config) error {
	logger.Debug("Reading input file: %s", cfg.InputFile)
	content, err := os.ReadFile(cfg.InputFile)
	if err != nil {
		return &TypegenError{
			Type:    ErrTypeIO,
			Message: fmt.Sprintf("Failed to read input file: %s", cfg.InputFile),
			File:    cfg.InputFile,
			Cause:   err,
		}
	}

	data := FileData{
		Package:   cfg.Package,
		InputFile: filepath.Base(cfg.InputFile),
	}

	// Parse constants
	logger.Debug("Parsing constants...")
	data.Constants = parseConstants(string(content))
	logger.Debug("Found %d constants", len(data.Constants))

	// Parse structs
	logger.Debug("Parsing structs...")
	data.Structs, err = parseStructs(string(content))
	if err != nil {
		return &TypegenError{
			Type:    ErrTypeParsing,
			Message: "Failed to parse structs",
			File:    cfg.InputFile,
			Cause:   err,
		}
	}
	logger.Debug("Found %d structs", len(data.Structs))

	// Validate parsed data
	if err := validateParsedData(data); err != nil {
		return err
	}

	// Generate Go code
	logger.Debug("Generating Go code...")
	tmpl, err := template.New("go").Parse(goTemplate)
	if err != nil {
		return &TypegenError{
			Type:    ErrTypeGeneration,
			Message: "Failed to parse Go template",
			Cause:   err,
		}
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return &TypegenError{
			Type:    ErrTypeGeneration,
			Message: "Failed to execute Go template",
			Cause:   err,
		}
	}

	// Format the generated code
	logger.Debug("Formatting generated code...")
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Write unformatted for debugging
		logger.Warn("Failed to format generated code, writing unformatted version for debugging")
		if writeErr := os.WriteFile(cfg.OutputFile, buf.Bytes(), 0644); writeErr != nil {
			return &TypegenError{
				Type:    ErrTypeIO,
				Message: "Failed to write unformatted output file",
				File:    cfg.OutputFile,
				Cause:   writeErr,
			}
		}
		return &TypegenError{
			Type:    ErrTypeGeneration,
			Message: "Failed to format generated Go code",
			File:    cfg.OutputFile,
			Cause:   err,
		}
	}

	// Write output
	logger.Debug("Writing output file: %s", cfg.OutputFile)
	if err := os.WriteFile(cfg.OutputFile, formatted, 0644); err != nil {
		return &TypegenError{
			Type:    ErrTypeIO,
			Message: "Failed to write output file",
			File:    cfg.OutputFile,
			Cause:   err,
		}
	}

	return nil
}

func parseConstants(content string) []Constant {
	var constants []Constant

	// Match #define NAME VALUE patterns where VALUE is a number
	matches := defineRe.FindAllStringSubmatch(content, -1)

	for _, match := range matches {
		name := match[1]
		value := match[2]

		// Skip header guards
		if strings.HasSuffix(name, "_H") || strings.HasPrefix(name, "__") {
			continue
		}

		// Convert C-style names to Go-style
		goName := toCamelCase(name)
		constants = append(constants, Constant{
			Name:  goName,
			Value: value,
		})
	}

	// Also handle expressions like (TOTAL_MAX_ARGS * ARGSIZE)
	// For now, we'll skip these as they need evaluation

	return constants
}

func parseStructs(content string) ([]Struct, error) {
	var structs []Struct
	structNames := make(map[string]bool)

	// Match struct definitions - use (?s) flag to make . match newlines
	matches := structRe.FindAllStringSubmatch(content, -1)

	for _, match := range matches {
		structName := match[1]
		body := match[2]

		goStructName := toGoStructName(structName)

		// Check for duplicate struct names
		if structNames[goStructName] {
			logger.Warn("Duplicate struct name found: %s", goStructName)
			continue
		}
		structNames[goStructName] = true

		s := Struct{
			Name: goStructName,
		}

		// Parse fields
		lines := strings.Split(body, "\n")
		for lineNum, line := range lines {
			line = strings.TrimSpace(line)
			if line == "" || strings.HasPrefix(line, "//") || strings.HasPrefix(line, "/*") || strings.HasPrefix(line, "*") {
				continue
			}

			field, err := parseField(line, lineNum+1)
			if err != nil {
				logger.Warn("Failed to parse field in struct %s line %d: %v", structName, lineNum+1, err)
				continue
			}
			if field != nil {
				s.Fields = append(s.Fields, *field)
			}
		}

		if len(s.Fields) > 0 {
			structs = append(structs, s)
			logger.Debug("Parsed struct %s with %d fields", s.Name, len(s.Fields))
		} else {
			logger.Warn("Struct %s has no parseable fields", structName)
		}
	}

	return structs, nil
}

func parseField(line string, lineNum int) (*StructField, error) {
	// Remove comments
	if idx := strings.Index(line, "//"); idx >= 0 {
		line = line[:idx]
	}
	line = strings.TrimSpace(line)

	// Skip empty lines or lines without semicolon
	if line == "" || !strings.HasSuffix(line, ";") {
		return nil, nil
	}

	// Remove semicolon
	line = strings.TrimSuffix(line, ";")
	line = strings.TrimSpace(line)

	// Match array fields: type name[size] where size can be a number or constant
	if matches := arrayRe.FindStringSubmatch(line); matches != nil {
		cType := matches[1]
		name := matches[2]
		sizeStr := matches[3]

		// Try to parse as number, otherwise look up constant
		size, err := strconv.Atoi(sizeStr)
		if err != nil {
			// Look up known constants
			if knownSize, ok := knownConstants[sizeStr]; ok {
				size = knownSize
			} else {
				logger.Warn("Unknown array size constant: %s at line %d", sizeStr, lineNum)
				return nil, nil
			}
		}

		goType := cToGoType(cType)
		return &StructField{
			Name:     toGoFieldName(name),
			CType:    cType,
			GoType:   fmt.Sprintf("[%d]%s", size, goType),
			IsArray:  true,
			ArrayLen: size,
		}, nil
	}

	// Match regular fields: type name
	if matches := fieldRe.FindStringSubmatch(line); matches != nil {
		cType := matches[1]
		name := matches[2]

		return &StructField{
			Name:   toGoFieldName(name),
			CType:  cType,
			GoType: cToGoType(cType),
		}, nil
	}

	// If we couldn't parse, log it for debugging
	if line != "" {
		logger.Debug("Could not parse field at line %d: %q", lineNum, line)
	}

	return nil, nil
}

func cToGoType(cType string) string {
	if goType, ok := cToGoTypes[cType]; ok {
		return goType
	}
	// Default to keeping the type as-is
	return cType
}

func toCamelCase(s string) string {
	// Handle special constants
	switch s {
	case "ARGSIZE":
		return "ArgSize"
	case "FULL_MAX_ARGS_ARR":
		return "FullMaxArgsArr"
	}

	parts := strings.Split(strings.ToLower(s), "_")
	for i, part := range parts {
		if part != "" {
			parts[i] = titleCase.String(part)
		}
	}
	return strings.Join(parts, "")
}

func toGoFieldName(s string) string {
	// Handle special cases first
	switch strings.ToLower(s) {
	case "pid":
		return "PID"
	case "ppid":
		return "PPID"
	case "uid":
		return "UID"
	case "gid":
		return "GID"
	case "tid":
		return "TID"
	case "retval":
		return "RetVal"
	}

	// Convert snake_case to CamelCase
	name := toCamelCase(s)

	return name
}

func toGoStructName(s string) string {
	// Remove _event suffix if present
	s = strings.TrimSuffix(s, "_event")

	// Convert to CamelCase
	camel := ""
	parts := strings.Split(s, "_")
	for _, part := range parts {
		if part != "" {
			// Keep uppercase parts (like SNOOP) as-is
			if part == strings.ToUpper(part) {
				camel += titleCase.String(strings.ToLower(part))
			} else {
				camel += titleCase.String(part)
			}
		}
	}

	// Add Event suffix
	return camel + "Event"
}
